---
// This "frontmatter" section is where we import styles in Astro
import '../assets/styles/index.css';
---

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Space+Grotesk:wght@300..700&family=Syne:wght@400..800&display=swap"
        rel="stylesheet">
    <script is:inline src="/lenis.js"></script>
</head>

<body>
    <nav>
        <img class="logo" src="/logo.png" alt="">
        <div class="menu">
            MENU
            <div class="menuDots">
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
        </div>
    </nav>
    <div class="grain"></div>
    <div id="trailer"></div>
    <canvas id="canvas"></canvas>
    <main class="center">
        <div class="brandName">
            <div class="sectionName">
                <div class="sectionNum">[001] introduction</div>
                <div class="sectionNameText">MAIT TECHNO-CULTURAL SOCIETY</div>
            </div>
            <div class="brandone"><span>CSI</span></div>
            <div class="brandtwo"><span>INNOWAVE</span></div>
        </div>
        <div class="brandTaglines">
            <div class="tagline-1">
                <span>That help marketing and ops teams <br> move faster.</span>
            </div>
            <div class="tagline-2">
                <span>Where innovation meets excellence</span>
            </div>
        </div>
        <div class="currentActivity">
            <div class="eventName">
                <div class="greenPulse"></div>
                <span>uncharted'25</span>
            </div>
            <div class="joinBtn center">
                Join Us
            </div>
        </div>
    </main>
</body>
<script is:inline>
    // tracker
    const trailer = document.getElementById("trailer");

    const animateTrailer = (e) => {
        trailer.style.display = "grid"
        const x = e.clientX - trailer.offsetWidth / 2,
            y = e.clientY - trailer.offsetHeight / 2;


        const scale = 1;

        const keyframes = {
            transform: `translate(${x}px, ${y}px) scale(${scale})`
        }

        trailer.animate(keyframes, {
            duration: 200,
            fill: "forwards"
        });
    }
    window.onmousemove = e => {
        animateTrailer(e);
    }


    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // --- CONFIGURATION ---
    const GRID_SPACING = 40;    // Distance between pluses
    const PLUS_SIZE = 6;        // Half-arm length of the plus (as before)
    const HOVER_RADIUS = 250;   // Effect radius
    const MIN_SCALE = 0.7;      // Inactive scale (60% of full)
    const MIN_LINE = 1.25;       // Inactive line width
    const MAX_LINE = 1.6;       // Active line width

    // Colors as objects (you can change these)
    const COLOR_ACTIVE = { r: 75, g: 75, b: 75 }; // bright color when active
    const COLOR_INACTIVE = { r: 255, g: 255, b: 255 };  // darker when inactive

    const INACTIVE_ALPHA = 0.15; // opacity for far pluses
    // ---------------------

    let width, height;
    let particles = [];

    // Mouse state
    const mouse = { x: -10000, y: -10000 };

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.angle = 0;
        }

        update() {
            const dx = mouse.x - this.x;
            const dy = mouse.y - this.y;
            const distance = Math.hypot(dx, dy);

            const isActive = distance < HOVER_RADIUS;

            // Defaults (inactive)
            let alpha = INACTIVE_ALPHA;
            let scale = MIN_SCALE;
            let lineW = MIN_LINE;
            let color = COLOR_INACTIVE;
            let angle = 0;

            if (isActive) {
                const pct = 1 - (distance / HOVER_RADIUS); // 0..1 (1 at center)

                // Interpolate visual properties
                alpha = INACTIVE_ALPHA + (1 - INACTIVE_ALPHA) * pct;
                scale = MIN_SCALE + (1 - MIN_SCALE) * pct;
                lineW = MIN_LINE + (MAX_LINE - MIN_LINE) * pct;
                angle = Math.atan2(dy, dx);

                // Lerp color between inactive and active
                color = {
                    r: Math.round(COLOR_INACTIVE.r + (COLOR_ACTIVE.r - COLOR_INACTIVE.r) * pct),
                    g: Math.round(COLOR_INACTIVE.g + (COLOR_ACTIVE.g - COLOR_INACTIVE.g) * pct),
                    b: Math.round(COLOR_INACTIVE.b + (COLOR_ACTIVE.b - COLOR_INACTIVE.b) * pct)
                };
            }

            this.angle = angle;
            this.draw(alpha, scale, lineW, color, isActive);
        }

        draw(alpha, scale, lineW, color, rotate) {
            ctx.save();
            ctx.translate(this.x, this.y);

            // Rotate only when active (rotate === true)
            if (rotate) ctx.rotate(this.angle);

            ctx.scale(scale, scale);

            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
            ctx.lineWidth = lineW;

            ctx.beginPath();
            // horizontal
            ctx.moveTo(-PLUS_SIZE, 0);
            ctx.lineTo(PLUS_SIZE, 0);
            // vertical
            ctx.moveTo(0, -PLUS_SIZE);
            ctx.lineTo(0, PLUS_SIZE);
            ctx.stroke();

            ctx.restore();
        }
    }

    function init() {
        particles = [];

        // size canvas
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;

        // small padding in px (roughly 1vw)
        const padding = width * 0.01;

        const safeWidth = width - (padding * 2);
        const safeHeight = height - (padding * 3);

        // how many points (columns/rows) fit â€” include the last edge point
        const cols = Math.floor(safeWidth / GRID_SPACING) + 1;
        const rows = Math.floor(safeHeight / GRID_SPACING) + 1;

        // actual pixel span of the grid (points are spaced by GRID_SPACING and there are cols-1 intervals)
        const gridRealWidth = (cols - 1) * GRID_SPACING;
        const gridRealHeight = (rows - 1) * GRID_SPACING;

        const startX = padding + (safeWidth - gridRealWidth) / 2;
        const startY = padding + (safeHeight - gridRealHeight) / 2;

        // Use < rather than <= to avoid an extra partial column/row
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const x = startX + i * GRID_SPACING;
                const y = startY + j * GRID_SPACING;
                // keep within padding bounds
                if (x >= padding && x <= width - padding && y >= padding && y <= height - padding) {
                    particles.push(new Particle(x, y));
                }
            }
        }
    }

    function animate() {
        ctx.clearRect(0, 0, width, height);

        for (let p of particles) p.update();

        requestAnimationFrame(animate);
    }

    // Events
    window.addEventListener('resize', () => {
        init();
    });

    window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });

    // When the mouse leaves, move it far away so everything becomes inactive
    window.addEventListener('mouseout', () => {
        mouse.x = -10000;
        mouse.y = -10000;
    });

    // init + animate
    init();
    animate();
</script>


</html>